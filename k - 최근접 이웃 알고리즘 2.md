# 목표
* 훈련 데이터와 테스트 데이터 나누기
* 평가

## ML에 필요한 패키지 삽입


```python
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
```

## 훈련 데이터와 테스트 데이터 나누기


```python
#도미의 길이(cm)와 무게(g) - 35마리
bream_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 
                31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 
                35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0]
bream_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 
                500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 
                700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0]

#빙어의 길이(cm)와 무게(g) - 14마리
smelt_length = [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]
smelt_weight = [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]

```

* 샘플링 편향(훈련 데이터와 테스트 데이터가 골고루 섞이지 않음)을 방지하기 위한 조치


```python
#넘파이 라이브러리의 이용
import numpy as np


input_data = np.array([bream_length+smelt_length,bream_weight+smelt_length]).T
target_data = np.r_[np.ones(35),np.zeros(14)]
print(input_data)
print(target_data)
```

    [[  25.4  242. ]
     [  26.3  290. ]
     [  26.5  340. ]
     [  29.   363. ]
     [  29.   430. ]
     [  29.7  450. ]
     [  29.7  500. ]
     [  30.   390. ]
     [  30.   450. ]
     [  30.7  500. ]
     [  31.   475. ]
     [  31.   500. ]
     [  31.5  500. ]
     [  32.   340. ]
     [  32.   600. ]
     [  32.   600. ]
     [  33.   700. ]
     [  33.   700. ]
     [  33.5  610. ]
     [  33.5  650. ]
     [  34.   575. ]
     [  34.   685. ]
     [  34.5  620. ]
     [  35.   680. ]
     [  35.   700. ]
     [  35.   725. ]
     [  35.   720. ]
     [  36.   714. ]
     [  36.   850. ]
     [  37.  1000. ]
     [  38.5  920. ]
     [  38.5  955. ]
     [  39.5  925. ]
     [  41.   975. ]
     [  41.   950. ]
     [   9.8    9.8]
     [  10.5   10.5]
     [  10.6   10.6]
     [  11.    11. ]
     [  11.2   11.2]
     [  11.3   11.3]
     [  11.8   11.8]
     [  11.8   11.8]
     [  12.    12. ]
     [  12.2   12.2]
     [  12.4   12.4]
     [  13.    13. ]
     [  14.3   14.3]
     [  15.    15. ]]
    [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.
     1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0.]



```python
#np.random을 이용하여 idex를 섞어줌! 이 index를 샘플의 index와 연결할 것이다.
np.random.seed(42)
index = np.arange(49)
np.random.shuffle(index)

print(index)
```

    [13 45 47 44 17 27 26 25 31 19 12  4 34  8  3  6 40 41 46 15  9 16 24 33
     30  0 43 32  5 29 11 36  1 21  2 37 35 23 39 10 22 18 48 20  7 42 14 28
     38]



```python
#훈련데이터를 셔플되어진 index를 이용하여 추출 35개
train_data = input_data[index[:35]]
train_target = target_data[index[:35]]

#테스트 데이터 14개
test_data = input_data[index[35:]]
test_target = target_data[index[35:]]
```

## 훈련데이터와 테스트 데이터의 shuffle 확인


```python
plt.scatter(train_data[:,0],train_data[:,1])
plt.scatter(test_data[:,0],test_data[:,1])
plt.xlabel('length')
plt.ylabel('wieght')
plt.show()
#아주 잘 섞여있군 !
```


​    
![output_10_0](../../images/k - 최근접 이웃 알고리즘 2/output_10_0.png)
​    



```python
kn = KNeighborsClassifier()
kn.fit(train_data,train_target)
kn.score(test_data,test_target)
```




    1.0



정확도 100% 과연 이 분류모델일 정확히 도미와 빙어를 분류할 수 있을까?

정확도 측정법만 개선 했을 뿐!

분료모델의 정확도가 올라간 것이 아니다!

무엇을 더 개선해주어야 할까 ? 

continue..........


```python

```
